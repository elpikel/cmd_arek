<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="Description" lang="en" content="Air quality station" />
        <meta name="keywords" content="Elixir, Phoenix, Ecto, Nerves, Air quality" />
        <meta
                name="author"
                content="Arkadiusz Plichta https://github.com/elpikel"
                />
        <meta name="robots" content="index, follow" />
        <title>cmdarek.com - Air quality station</title>
        <link rel="preconnect" href="https://fonts.gstatic.com" />
        <link
                href="https://fonts.googleapis.com/css2?family=Bungee+Outline&family=Roboto+Mono:wght@500&family=Roboto:wght@400;500&display=swap"
                rel="stylesheet"
                />
        <link
                rel="stylesheet"
                href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"
                />
        <link rel="stylesheet" href="../styles/hybrid.css" />
        <link rel="apple-touch-icon" href="../images/logo.svg" />
        <link rel="shortcut icon" href="../images/logo.svg" />
        <link rel="icon" href="images/logo.svg" />
        <link rel="stylesheet" href="../styles/general.css" />
        <script src="../js/highlight.pack.js"></script>
        <script>
            hljs.initHighlightingOnLoad();
        </script>
    </head>

    <body>
        <div class="container">
            <div class="header">
                <a href="../index.html">
                    <img src="../images/logo.svg" alt="logo" />
                    <h1>cmdarek</h1>
                </a>
                <div>
                    <a
                            target="_blank"
                            href="https://twitter.com/el_pikel"
                            class="fa fa-twitter"
                            ></a>
                    <a
                            target="_blank"
                            href="https://github.com/elpikel"
                            class="fa fa-github"
                            ></a>
                </div>
            </div>
            <div class="content">
                <div class="main">
                    <span>05-08-2022</span>
                    <h2>Air quality station</h2>
                    <p>
                    Brief description of what and why we want to build.
                    <img src="../images/air-quality-station.jpg" class="center img-responsive" />
                    </p>
                    <p>
                    <h4>Architecture</h4>
                    </p>
                    <p>
                    <h4>Device</h4>
                    <pre>
                    <code class="elixir">
defmodule Hermus.UdpClient do
  use GenServer

  alias Hermus.AirQuality

  def start_link(port \\ 8681) do
    GenServer.start_link(__MODULE__, port)
  end

  def init(port) do
    :gen_udp.open(port, [:binary, active: true, broadcast: true])
  end

  def handle_info({:udp, socket, address, port, "ping"}, state) do
    probe = AirQuality.last_probe()

    :gen_udp.send(
      socket,
      address,
      port,
      Jason.encode!(%{device_id: Application.fetch_env!(:hermus, :id), probe: probe})
    )

    {:noreply, state}
  end
end
                    </code>
                    </pre>

                    <pre>
                    <code class="elixir">
defmodule Hermus.AirQuality do
  use GenServer

  alias Hermus.SDS011

  def start_link(_args) do
    GenServer.start_link(__MODULE__, %{last_probe: nil}, name: __MODULE__)
  end

  def last_probe() do
    GenServer.call(__MODULE__, :last_probe)
  end

  @impl true
  def init(state) do
    {:ok, pid} = Circuits.UART.start_link()

    Circuits.UART.open(pid, port(), active: true)

    {:ok, state}
  end

  @impl true
  def handle_call(:last_probe, _from, state) do
    {:reply, state.last_probe, state}
  end

  @impl true
  def handle_info({:circuits_uart, _usb, message}, state) do
    probe = SDS011.decode!(message)

    state = %{state | last_probe: probe}

    {:noreply, state}
  end

  defp port() do
    Circuits.UART.enumerate()
    |> Enum.find(fn {_key, value} -> value != %{} end)
    |> then(fn
      {port, _} -> port
      _ -> nil
    end)
  end
end
                    </code>
                    </pre>
                    </p>
                    <p>
                    <h4>Dashboard</h4>
                    <pre>
                    <code class="elixir">
defmodule Hermus.UdpServer do
  use GenServer

  alias Hermus.DevicesRegistry
  alias Hermus.DevicesSupervisor
  alias Hermus.Device

  def start_link(port \\ 8680) do
    GenServer.start_link(__MODULE__, port)
  end

  def init(port) do
    {:ok, network_info} = :inet.getif()
    {_ip_address, broadcast_address, _} = find_local(network_info)

    {:ok, socket} = :gen_udp.open(port, [:binary, active: true, broadcast: true])

    {:ok, %{socket: socket, broadcast_address: broadcast_address}, {:continue, :init}}
  end

  def handle_continue(:init, state) do
    send(self(), :ask_for_data)

    {:noreply, state}
  end

  def handle_info(
        :ask_for_data,
        %{socket: socket, broadcast_address: broadcast_address} = state
      ) do
    :gen_udp.send(socket, broadcast_address, 8681, "ping")

    Process.send_after(self(), :ask_for_data, 1_000)

    {:noreply, state}
  end

  def handle_info({:udp, _socket, _address, _port, data}, state) do
    %{"device_id" => device_id, "probe" => probe} = Jason.decode!(data)

    if !DevicesRegistry.exist?(device_id) do
      DevicesSupervisor.start_child(device_id)
    end

    Device.add_probe(probe, device_id)

    {:noreply, state}
  end

  defp find_local(networks) do
    Enum.find(networks, fn {_, broadcast_address, _} -> broadcast_address != :undefined end)
  end
end
                    </code>
                    </pre>

                    <pre>
                    <code class="elixir">
defmodule Hermus.DevicesRegistry do
  @name :devices_registry

  def name do
    @name
  end

  def via_tuple(device_identifier) do
    {:via, Registry, {@name, device_identifier}}
  end

  def exist?(device_identifier) do
    Registry.lookup(@name, device_identifier) != []
  end
end
                    </code>
                    </pre>

                    <pre>
                    <code class="elixir">
defmodule Hermus.DevicesSupervisor do
  use DynamicSupervisor
  alias Hermus.Device

  def start_link(_arg) do
    DynamicSupervisor.start_link(__MODULE__, [], name: __MODULE__)
  end

  def start_child(device_identifier) do
    child_specification = {Device, device_identifier}

    DynamicSupervisor.start_child(__MODULE__, child_specification)
  end

  @impl true
  def init(_arg) do
    DynamicSupervisor.init(strategy: :one_for_one)
  end
end
                    </code>
                    </pre>


                    <pre>
                    <code class="elixir">
defmodule Hermus.Device do
  use GenServer

  alias Hermus.Devices
  alias Hermus.DevicesRegistry

  def start_link(device_identifier) do
    GenServer.start_link(__MODULE__, device_identifier,
      name: DevicesRegistry.via_tuple(device_identifier)
    )
  end

  def add_probe(probe, device_identifier) when not is_nil(probe) do
    device_identifier
    |> DevicesRegistry.via_tuple()
    |> GenServer.cast({:add_probe, probe})
  end

  def child_spec(device_identifier) do
    %{
      id: __MODULE__,
      start: {__MODULE__, :start_link, [device_identifier]},
      restart: :transient
    }
  end

  @impl true
  def init(device_identifier) do
    %{id: device_id} = Devices.add_device(device_identifier)

    {:ok, device_id}
  end

  @impl true
  def handle_cast({:add_probe, probe}, device_id) do
    probe = Devices.add_probe(device_id, probe)

    Phoenix.PubSub.broadcast(Hermus.PubSub, "probe", probe)

    {:noreply, device_id}
  end
end
                    </code>
                    </pre>
 
                    <pre>
                    <code class="elixir">
defmodule HermusWeb.ProbeLive.Index do
  use HermusWeb, :live_view

  alias Hermus.Devices
  alias Hermus.Models

  @probes_limit 20

  @impl true
  def mount(_params, _session, socket) do
    if connected?(socket) do
      Phoenix.PubSub.subscribe(Hermus.PubSub, "probe")
    end

    {:ok, assign(socket, :devices, list_devices())}
  end

  @impl true
  def handle_info(%Models.Probe{} = probe, socket) do
    handle_new_probe(probe, socket)
  end

  defp handle_new_probe(probe, socket) do
    devices = socket.assigns.devices

    updated_devices =
      update_in(devices[probe.device_id], fn device ->
        probes =
          device.probes
          |> add(probe)
          |> window()

        %{device | probes: probes}
      end)

    socket = assign(socket, devices: updated_devices)

    {:noreply, push_event(socket, "probe", probe)}
  end

  defp add(probes, probe) do
    [probe | probes]
  end

  defp window(probes) do
    Enum.take(probes, @probes_limit)
  end

  defp list_devices() do
    @probes_limit
    |> Devices.list()
    |> Enum.into(%{}, fn device ->
      {device.id, device}
    end)
  end
end
                    </code>
                    </pre>
                    </p>

                    <p>
                    You can view full code at:
                    <a href="https://github.com/elpikel/hermus">https://github.com/elpikel/hermus</a>
                    </p>
                </div>
            </div>
        </div>
    </body>
</html>
